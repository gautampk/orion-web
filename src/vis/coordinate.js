import WebMercatorViewport from 'viewport-mercator-project';
import {
  MAP_FIT_TYPE_CURRENT,
  MAP_FIT_TYPE_FULL,
} from 'app/redux/reducers/filters';

/**
 * Create a unique array according a particular predicate.
 *
 * @param {Array} arr Input array.
 * @param {Function} predicate Unary function that takes as input the array element and returns a
 *                             string key that uniquely identifies that element. Elements with the
 *                             same key will be deduplicated, favoring the later element in the
 *                             array.
 * @returns {Array} Same input data but with elements deduplicated according to the key generated by
 *                  the specified predicate.
 */
const uniqBy = (arr, predicate) => Object.values(arr
  .map((elem) => ({ key: predicate(elem), elem }))
  .reduce((unique, { key, elem }) => ({
    ...unique,
    [key]: elem,
  }), {}));

/**
 * Determine the appropriate center coordinate and zoom level for the map, given an array of data.
 *
 * @param {Array} data Array of location objects.
 * @param {number} accuracyThreshold Maximum tolerable accuracy threshold in meters.
 * @param {number} width Current width of the viewport.
 * @param {number} height Current height of the viewport.
 * @returns {Object} An object containing center and zoom properties describing how best to fit the
 *                   map bounds to the data..
 */
export const fitMapBounds = (data, accuracyThreshold, mapFitType, width, height) => {
  // Fit only location points that are unique keyed by their latitude and longitude.
  const eligibleData = data.filter(({ accuracy }) => accuracy < accuracyThreshold);
  let mapFitData;

  if (mapFitType === MAP_FIT_TYPE_FULL) {
    mapFitData = uniqBy(
      eligibleData,
      ({ latitude, longitude }) => `${latitude}-${longitude}`,
    );
  } else if (mapFitType === MAP_FIT_TYPE_CURRENT) {
    // Instead of de-duplicating the data we will find the latest entry.
    mapFitData = eligibleData.slice().sort((a, b) => {
      let retval;

      if (a.timestamp > b.timestamp) {
        retval = 1;
      } else if (a.timestamp < b.timestamp) {
        retval = -1;
      } else {
        retval = 0;
      }

      return retval;
    }).slice(-1);
  } else {
    mapFitData = eligibleData;
  }

  const dedupedData = mapFitData;

  // Use a sane default zoom level if there's only a single eligible point.
  if (dedupedData.length === 1) {
    const [{ latitude, longitude }] = dedupedData;
    return { latitude, longitude, zoom: 15 };
  }

  const { minLongitude, minLatitude, maxLongitude, maxLatitude } = dedupedData
    .reduce((acc, val) => ({
      minLongitude: Math.min(acc.minLongitude, val.longitude),
      maxLongitude: Math.max(acc.maxLongitude, val.longitude),
      minLatitude: Math.min(acc.minLatitude, val.latitude),
      maxLatitude: Math.max(acc.maxLatitude, val.latitude),
    }), {
      minLongitude: Infinity,
      maxLongitude: -Infinity,
      minLatitude: Infinity,
      maxLatitude: -Infinity,
    });

  const bounds = [[minLongitude, minLatitude], [maxLongitude, maxLatitude]];

  return new WebMercatorViewport({ width, height }).fitBounds(bounds, { padding: 40 });
};

export default undefined;
